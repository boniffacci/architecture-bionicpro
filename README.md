# Реализация задания 8-го спринта

## Задание

1. **Реализуйте PKCE**. Его нужно добавить к существующим приложениям — фронтенду и Keycloak. Мы специально не рассказывали в теории, как это сделать. Чтобы разобраться, изучите [официальную документацию](https://www.keycloak.org/docs/latest/server_admin/index.html#device-authorization-grant).
2. Создайте бэкенд-часть приложения для API. Выберите удобный для вас язык — Python, Java, C# или любой другой. Добавьте API `/reports` в этот бэкенд для передачи отчётов. Тут не требуется поход в базы данных, ограничьтесь генерацией произвольных данных.

**Перед отправкой задания проверьте, что:**

1. Бэкенд отдаёт данные только пользователям с ролью prothetic_user. Эту роль мы добавили в последнем уроке первой темы.
2. Бэкенд проверяет валидность подписи токена. Если валидация не прошла, он выдаёт ошибку 401.

## Решение

### 1. Поддержка PKCE

Добавление поддержки PKCE реализовано путём добавления опций в конструктор `ReactKeycloakProvider`.

Дополнительно добавлены кнопка выхода и примитивный показ полученного отчёта

### 2. Бэкенд-часть приложения для API

Бэкенд реализован на Python/[FastAPI](https://fastapi.tiangolo.com/).

Производится верификация полученного токена (подпись и атрибуты). Проверяется также роль пользователя на соответствие
указанной через переменную окружения `KEYCLOAK_ALLOWED_ROLE` роли(по умолчанию `prothetic_user`).

Для запуска сервиса необходимо поместить сервисный секрет для обращения к Keycloak в файл. При запуске сервиса путь к файлу указывается через переменную окружения `KEYCLOAK_CLIENT_SECRET_FILE`. Для передачи файла внутрь контейнера используется механизм секретов.

Также необходимо задать переменные окружения, требуемые сервису для работы:

* KEYCLOAK_URL — адрес сервера Keycloak. При запуске внутри докера предположительно равен http://keycloak:8080/
* KEYCLOAK_REALM
* KEYCLOAK_CLIENT_ID
* ALLOWED_CORS_ORIGINS

Эндпойнт `/reports' выдаёт в качестве результата отчёт в следующем формате:

```python
class ReportRow(BaseModel):
    id: UUID = Field(description = 'ID показания')
    received: datetime = Field(description = 'время получения показания')
    status: str = Field(description = 'статус датчика')
    sensor: str = Field(description = 'название датчика')
    value: str = Field(description = 'значение датчика')

class Report(BaseModel):
    user_id: UUID = Field(description = 'ID пользователя')
    generated: datetime = Field(description = 'время генерации отчёта')
    rows: List[ReportRow] = Field(description = 'список показаний')
```

Помимо эндпойнта `/reports` поддерживается эндпойнт `/ping` для определения жизнеспособности сервиса.

#### Запуск

Набор сервисов запускается через `docker compose up`/`podman compose up`.
По умолчанию используется режим запуска `DEV`. При необходимости запустить сервис в продакшне значение переменной окружения `APP_MODE` должна быть равно `PROD`

#### Интеграционное тестирование

Непосредственно перед запуском интеграционного тестирования необходимо поместить в файл [reports-api/tests-jwt.env](reports-api/tests-jwt.env) 3 необходимых JWT токена:

1. в переменную `JWT_VALID` — действующий токен пользователя с ролью, указанной в `KEYCLOAK_ALLOWED_ROLE`. Обычное время действия такого токена — 5-10 минут, поэтому необходимо регулярно обновлять этот токен.
2. в переменную `JWT_VALID_WRONG_USER` — действующий токен пользователя **без роли**, указанной в `KEYCLOAK_ALLOWED_ROLE`. Обычное время действия такого токена — 5-10 минут, поэтому необходимо регулярно обновлять этот токен.
3. в переменную `JWT_EXPIRED` — токен с истёкшим или не начавшимся сроком действия. 

Для запуска набора сервисов и проведения интеграционного тестирования можно использовать команду `podman compose --profile tests up --force-recreate`.
